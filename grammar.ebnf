(*
* Copyright: Copyright Ioannis Cheilaris 2019.
* License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
* Authors:   Ioannis Cheilaris, Stefanos Baziotis
*)


Module = {Declaration}, ? EOI ? ;

Declaration = StructDecl | FunctionDef;

FunctionDef = "func", Identifier, "(", FuncDefParamList, ")", [":", Type] "{", {Statement},
    "}";

FuncDefParamList = [ ParamSet, {",", ParamSet} ];

ParamSet = ParamIdentifierList, ":", Type;

ParamIdentifierList = Identifier, {",", Identifier};

StructDecl = "struct", Identifier, "{", {StructField}, "}";

StructField = Identifier, ":", Type, ";";


Statement = "{", {Statement}, "}" 
          | "while", "(", Expression, ")", Statement
          | LValue, "=", Expression, ";"
          | Identifier, "[", Expression, "]", "=", Expression, ";"
          | "if", "(", Expression, ")", Statement
          | FunctionCall, ";"
          | "return", [Expression], ";";


(*
  Note that we only need to support Identifier.Identifier and not an arbitrary
  number of .field, like a.b.c = 2 or a    .b.c.d = 2; That is because structs
  and arrays are always references, i.e. pointers. So, the above can be achieved
  as: B b = a.b;  // This is a pointer - any change to this will be reflected to
  a.b b.c = 2; For the same reason, we don't need to support something like:
  a.b[2] = 3;
  because we can achieve that as:
  Arr arr = a.b;  // arr is a pointer under the hood - any change to its
  elements will be reflected to a.b arr = a.b;
*)

LValue = Identifier, [ ".", Identifier ];

Expression = FunctionCall
           | NotExpression
           | ArrayLookupExpression
           | BinaryExpression;

FunctionCall = Identifier, "(", FuncCallArgList, ")";

FuncCallArgList = [ Expression, {",", Expression} ];

(*
  Expression precedence is simulated by using levels.
  The higher the level, the bigger the precedence.
*)

BinaryExpression = Level1Expr, [ "&&", Level1Expr, [BinaryExpression]];

Level1Expr = Level2Expr, [ "||", Level2Expr, [Level1Expr]];

Level2Expr = Level3Expr, [ ( "<" || "<=" || ">" || ">=" || "==" || "!="), Level3Expr, [Level2Expr] ];

Level3Expr = Level4Expr, [ ("+" || "-"), Level4Expr, [Level3Expr]];

Level4Expr = ExpressionTerm, [ ("*" || "/" || "%"), ExpressionTerm, [Level4Expr]];


NotExpression = { "!" }, ExpressionTerm;

ArrayLookupExpression = ExpressionTerm, "[", ExpressionTerm, "]";

ParenExpression = "(", Expression, ")";

ExpressionTerm = Integer
               | LValue 
               | "true" 
               | "false" 
               | "new", "int", "[", Expression,"]"
               | ParenExpr;


Type = "int"
     | "int", "[", "]"
     | "bool"
     | Identifier;


Integer = ? INTEGER_LITERAL ?;
Identifier = ? IDENTIFIER ? ;
